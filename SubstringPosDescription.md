#  Бесконечная последовательность
###Задание:

Возьмём бесконечную цифровую последовательность, образованную склеиванием последовательных положительных чисел: S = 123456789101112131415...
Определите первое вхождение заданной последовательности A в бесконечной последовательности S (нумерация начинается с 1).

Пример входных данных:
+ 6789
+ 111

Пример выходных данных:
+ 6
+ 12

###Основные положения:
1. Искомая последовательность цифр вводится с клавиатуры. 
2. Это должна быть непустая строка, составленная из символов "0-9"

###Описание класса Searcher

 - **getPos(String subString)** - возвращает искомый номер позиции строки subString.
 - **getFirstNumber(String subString, int start, int len)** - возвращает число, соответствующее start, len, SubString. Возвращает -1, если такого числа нет.
 - **generateString(String subString, int start, int firstNumber)** - строит строку длины subString.length(), на основании firstNumber, start.
 - **index(int n)** - возвращает позицию числа n в бесконечной цифровой последовательности.

###Алгоритм программы:
1) Строка полностью состоит из k нулей - такая последовательность встречается первый раз в числе 10^k, находим искомую позицию с помощью метода index();
2) Строка не полностью состоит из нулей, ее длина n. Идея в том, чтобы, задавшись len - длиной первого числа в подстроке, перебирать в цикле значение start (0 <= start < len) - номер позиции, с которой начинается первое число. Для каждого start строим строку длины n с помощью **generateString()**. 
		1.Если метод **generateString()** вернул строку, равную искомой подстроке - значит, искомая подстрока удовлетворяет значениям len, start, возвращаем номер позиции, используя метод **index()**. 
		2.Иначе, продолжаем перебирать len, start.
При одном и том же значении len искомая подстрока может удовлетворять нескольким значениям start, поэтому возвращаем минимальный номер позиции.
